// Check this script! No 'fetch', no 'XMLHttpRequest'. 
// Everything happens in local variable 'input' and 'output'.

function formatJSON() {
    const input = document.getElementById('input');
    const successMsg = document.getElementById('msg-success');
    const errorMsg = document.getElementById('msg-error');
    
    try {
        // 1. Parsing: Browser memory -> JS Object
        const obj = JSON.parse(input.value);
        
        // 2. Formatting: JS Object -> String (with 4 spaces indentation)
        const formatted = JSON.stringify(obj, null, 4);
        
        // 3. Update UI
        input.value = formatted;
        
        successMsg.innerText = "Formatted successfully!";
        successMsg.style.display = 'inline-block';
        errorMsg.style.display = 'none';
        setTimeout(() => successMsg.style.display = 'none', 3000);
    } catch (e) {
        errorMsg.innerText = "Error: " + e.message;
        errorMsg.style.display = 'inline-block';
        successMsg.style.display = 'none';
    }
}

function minifyJSON() {
    const input = document.getElementById('input');
    try {
        const obj = JSON.parse(input.value);
        input.value = JSON.stringify(obj);
    } catch (e) {
        alert("Invalid JSON");
    }
}

// --- New Feature: JSON to Go Struct ---
function jsonToGo() {
    const input = document.getElementById('input');
    const outputGo = document.getElementById('output-go');
    const errorMsg = document.getElementById('msg-error');
    const successMsg = document.getElementById('msg-success');

    try {
        const obj = JSON.parse(input.value);
        
        // Root struct name
        const goCode = "type AutoGenerated struct {\n" + generateGoStruct(obj, 1) + "}";
        
        outputGo.value = goCode;
        successMsg.innerText = "Converted to Go Struct!";
        successMsg.style.display = 'inline-block';
        errorMsg.style.display = 'none';
    } catch (e) {
        errorMsg.innerText = "Error: " + e.message;
        errorMsg.style.display = 'inline-block';
        outputGo.value = "";
    }
}

// Recursive function to generate struct fields
function generateGoStruct(obj, indentLevel) {
    let result = "";
    const indent = "\t".repeat(indentLevel);
    
    for (const key in obj) {
        const value = obj[key];
        const fieldName = toPascalCase(key);
        const jsonTag = ` \`json:"${key}"\``;
        let type = "interface{}";

        if (value === null) {
            type = "interface{}"; // or *string, difficult to guess
        } else if (typeof value === "string") {
            type = "string";
        } else if (typeof value === "number") {
            type = Number.isInteger(value) ? "int" : "float64";
        } else if (typeof value === "boolean") {
            type = "bool";
        } else if (Array.isArray(value)) {
            // Simple check for array type (checking first element)
            if (value.length > 0) {
                const first = value[0];
                if (typeof first === "string") type = "[]string";
                else if (typeof first === "number") type = Number.isInteger(first) ? "[]int" : "[]float64";
                else if (typeof first === "boolean") type = "[]bool";
                else if (typeof first === "object") {
                    // Inline struct for array of objects
                    type = "[]struct {\n" + generateGoStruct(first, indentLevel + 1) + indent + "}";
                }
            } else {
                type = "[]interface{}";
            }
        } else if (typeof value === "object") {
            // Nested struct
            type = "struct {\n" + generateGoStruct(value, indentLevel + 1) + indent + "}";
        }

        result += `${indent}${fieldName} ${type}${jsonTag}\n`;
    }
    return result;
}

// Helper: convert "user_id" -> "UserId"
function toPascalCase(str) {
    return str
        .replace(/[^a-zA-Z0-9]+(.)/g, (m, chr) => chr.toUpperCase())
        .replace(/^[a-z]/, c => c.toUpperCase());
}
